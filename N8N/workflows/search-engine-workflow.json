{
  "name": "Search Engine",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "search",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "search-webhook-trigger",
      "name": "Search Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "webhookId": "search-engine-webhook"
    },
    {
      "parameters": {
        "jsCode": "// FIXED: Proper n8n webhook input structure handling\n// In n8n, webhook data structure is: {headers, params, query, body, webhookUrl, executionMode}\n// The actual JSON payload is in the 'body' property\nconst webhookData = $input.all()[0]?.json;\n\n// Extract the actual payload from the body\nconst inputData = webhookData?.body;\n\n// Validate that we have webhook data\nif (!webhookData) {\n  return [{\n    json: {\n      success: false,\n      error: \"Invalid webhook format - no webhook data received\",\n      errorType: \"missing_webhook_data\",\n      debugInfo: {\n        inputAllLength: $input.all().length,\n        inputItem: $input.all()[0],\n        hasJson: !!$input.all()[0]?.json\n      }\n    }\n  }];\n}\n\n// Validate that we have body data\nif (!inputData) {\n  return [{\n    json: {\n      success: false,\n      error: \"Invalid webhook format - no body payload received\",\n      errorType: \"missing_body_payload\",\n      debugInfo: {\n        webhookDataKeys: Object.keys(webhookData),\n        hasBody: !!webhookData.body,\n        inputDataKeys: Object.keys(inputData || {}),\n        webhookStructure: {\n          hasHeaders: !!webhookData.headers,\n          hasParams: !!webhookData.params,\n          hasQuery: !!webhookData.query,\n          hasBody: !!webhookData.body,\n          hasWebhookUrl: !!webhookData.webhookUrl,\n          hasExecutionMode: !!webhookData.executionMode\n        }\n      }\n    }\n  }];\n}\n\n// Validate that parsedQuery exists\nif (!inputData.parsedQuery) {\n  return [{\n    json: {\n      success: false,\n      error: \"Invalid input format - missing parsedQuery\",\n      errorType: \"validation_error\",\n      debugInfo: {\n        inputDataKeys: Object.keys(inputData),\n        hasParsedQuery: !!inputData.parsedQuery,\n        inputDataSample: {\n          originalQuery: inputData.originalQuery,\n          hasParsedQuery: !!inputData.parsedQuery\n        }\n      }\n    }\n  }];\n}\n\nconst { parsedQuery } = inputData;\n\n// Validate required fields\nif (!parsedQuery.jobTitles || parsedQuery.jobTitles.length === 0) {\n  return [{\n    json: {\n      success: false,\n      error: \"No job titles found in query - cannot search\",\n      errorType: \"missing_job_titles\",\n      debugInfo: {\n        parsedQueryKeys: Object.keys(parsedQuery),\n        jobTitles: parsedQuery.jobTitles,\n        jobTitlesType: typeof parsedQuery.jobTitles,\n        jobTitlesLength: parsedQuery.jobTitles ? parsedQuery.jobTitles.length : 0\n      }\n    }\n  }];\n}\n\n// Valid input, proceed with search\nreturn [{\n  json: {\n    success: true,\n    originalQuery: inputData.originalQuery,\n    parsedQuery: parsedQuery,\n    status: \"validated\",\n    debugInfo: {\n      validationMethod: \"webhook.body.access\",\n      inputStructure: \"webhook_body_correctly_parsed\",\n      webhookDataKeys: Object.keys(webhookData)\n    }\n  }\n}];"
      },
      "id": "validate-search-input",
      "name": "Validate Search Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "jsCode": "// FIXED: Handle direct node-to-node data transfer from Validate Search Input\n// The previous node outputs: {success: true, originalQuery, parsedQuery, status}\n// This node receives that data directly, not as webhook structure\nconst inputData = $input.all()[0]?.json;\n\n// Check if input data exists (direct from previous node)\nif (!inputData) {\n  return [{\n    json: {\n      success: false,\n      error: \"No input data received from Validate Search Input node\",\n      errorType: \"missing_node_input\",\n      errorDetails: \"Expected direct input from previous node with structure: {success: true, originalQuery, parsedQuery, status}\",\n      debugInfo: {\n        inputAllLength: $input.all().length,\n        firstInput: $input.all()[0],\n        hasJson: !!$input.all()[0]?.json\n      }\n    }\n  }];\n}\n\n// Validate that we received successful validation from previous node\nif (!inputData.success || inputData.success !== true) {\n  return [{\n    json: {\n      success: false,\n      error: \"Previous node validation failed\",\n      errorType: \"validation_failed\",\n      errorDetails: \"Validate Search Input node returned success=false\",\n      receivedInput: inputData\n    }\n  }];\n}\n\n// Extract and validate parsedQuery from direct node input\nconst { parsedQuery, originalQuery } = inputData;\n\nif (!parsedQuery) {\n  return [{\n    json: {\n      success: false,\n      error: \"parsedQuery object is missing from node input\",\n      errorType: \"missing_parsedQuery\",\n      errorDetails: \"Expected input structure from Validate Search Input: {success: true, originalQuery: '...', parsedQuery: {...}, status: 'validated'}\",\n      receivedInput: inputData\n    }\n  }];\n}\n\n// Validate that parsedQuery has required structure\nif (typeof parsedQuery !== 'object' || parsedQuery === null) {\n  return [{\n    json: {\n      success: false,\n      error: \"parsedQuery is not a valid object\",\n      errorType: \"invalid_parsedQuery\",\n      errorDetails: `Expected parsedQuery to be an object, got: ${typeof parsedQuery}`,\n      parsedQuery: parsedQuery\n    }\n  }];\n}\n\n// Build search components\nconst siteFilter = \"site:linkedin.com/in/\";\nconst searchComponents = [];\n\n// Add job titles (exact match for better results)\nif (parsedQuery.jobTitles && Array.isArray(parsedQuery.jobTitles) && parsedQuery.jobTitles.length > 0) {\n  const titleQueries = parsedQuery.jobTitles.map(title => `\"${title}\"`);\n  searchComponents.push(`(${titleQueries.join(\" OR \")})`);\n}\n\n// Add skills\nif (parsedQuery.skills && Array.isArray(parsedQuery.skills) && parsedQuery.skills.length > 0) {\n  const skillQueries = parsedQuery.skills.map(skill => skill);\n  searchComponents.push(`(${skillQueries.join(\" OR \")})`);\n}\n\n// Add location\nif (parsedQuery.location && typeof parsedQuery.location === 'string' && parsedQuery.location.trim()) {\n  searchComponents.push(`\"${parsedQuery.location.trim()}\"`);\n}\n\n// Add experience if specified\nif (parsedQuery.experience && !isNaN(parsedQuery.experience)) {\n  searchComponents.push(`\"${parsedQuery.experience}+ years\" OR \"${parsedQuery.experience}+ years\"`);\n}\n\n// Add keywords\nif (parsedQuery.keywords && Array.isArray(parsedQuery.keywords) && parsedQuery.keywords.length > 0) {\n  searchComponents.push(parsedQuery.keywords.join(\" \"));\n}\n\n// Add company type filter\nif (parsedQuery.companyType && typeof parsedQuery.companyType === 'string' && parsedQuery.companyType.trim()) {\n  searchComponents.push(parsedQuery.companyType.trim());\n}\n\n// Combine all components\nconst searchQuery = `${siteFilter} ${searchComponents.join(\" \")}`.trim();\n\n// Alternative queries for better coverage\nconst alternativeQueries = [];\n\n// Simpler query with just job titles\nif (parsedQuery.jobTitles && Array.isArray(parsedQuery.jobTitles) && parsedQuery.jobTitles.length > 1) {\n  const simpleQuery = `${siteFilter} \"${parsedQuery.jobTitles[0]}\"`;\n  alternativeQueries.push(simpleQuery);\n}\n\n// Query with location emphasis\nif (parsedQuery.location && typeof parsedQuery.location === 'string' && parsedQuery.location.trim() && \n    parsedQuery.jobTitles && Array.isArray(parsedQuery.jobTitles) && parsedQuery.jobTitles.length > 0) {\n  const locationQuery = `${siteFilter} \"${parsedQuery.jobTitles[0]}\" \"${parsedQuery.location.trim()}\"`;\n  alternativeQueries.push(locationQuery);\n}\n\n// Success response\nreturn [{\n  json: {\n    success: true,\n    originalQuery: originalQuery || '',\n    parsedQuery: parsedQuery,\n    searchQuery: searchQuery,\n    alternativeQueries: alternativeQueries,\n    queryComplexity: searchComponents.length,\n    validation: {\n      hasJobTitles: !!(parsedQuery.jobTitles && parsedQuery.jobTitles.length > 0),\n      hasSkills: !!(parsedQuery.skills && parsedQuery.skills.length > 0),\n      hasLocation: !!(parsedQuery.location && typeof parsedQuery.location === 'string'),\n      hasExperience: !!(parsedQuery.experience && !isNaN(parsedQuery.experience)),\n      hasKeywords: !!(parsedQuery.keywords && parsedQuery.keywords.length > 0)\n    },\n    debugInfo: {\n      dataTransferMethod: \"direct_node_input\",\n      inputSource: \"Validate_Search_Input_node\",\n      expectedStructure: \"{success: true, originalQuery, parsedQuery, status}\"\n    }\n  }\n}];"
      },
      "id": "build-search-query",
      "name": "Construct Google Search Query",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "url": "https://serpapi.com/search",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "api_key",
              "value": "={{ $credentials.serpApi?.apiKey || $env.SERPAPI_API_KEY }}"
            },
            {
              "name": "engine",
              "value": "google"
            },
            {
              "name": "q",
              "value": "={{ $json.searchQuery }}"
            },
            {
              "name": "location",
              "value": "={{ $json.parsedQuery.location || 'United States' }}"
            },
            {
              "name": "google_domain",
              "value": "google.com"
            },
            {
              "name": "gl",
              "value": "us"
            },
            {
              "name": "hl",
              "value": "en"
            },
            {
              "name": "num",
              "value": "10"
            },
            {
              "name": "device",
              "value": "desktop"
            }
          ]
        },
        "options": {}
      },
      "id": "serpapi-search",
      "name": "SerpApi Google Search",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [900, 200],
      "credentials": {
        "serpApi": {
          "id": "serpapi-credentials",
          "name": "SerpApi API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const serpApiResponse = $input.all()[0]?.json;\nconst searchParams = $(\"Construct Google Search Query\").all()[0]?.json;\n\nif (!serpApiResponse || serpApiResponse.error) {\n  return [{\n    json: {\n      success: false,\n      error: serpApiResponse?.error || \"SerpApi API error\",\n      errorType: \"serpapi_error\",\n      searchParams: searchParams,\n      apiUsed: \"serpapi_failed\"\n    }\n  }];\n}\n\n// Extract organic results\nconst organicResults = serpApiResponse.organic_results || [];\n\n// Filter for LinkedIn profiles only\nconst linkedinResults = organicResults\n  .filter(result => {\n    const url = result.link || '';\n    return url.includes('linkedin.com/in/') && !url.includes('/pub/');\n  })\n  .slice(0, 10) // Limit to 10 results\n  .map((result, index) => ({\n    title: result.title || '',\n    url: result.link || '',\n    snippet: result.snippet || '',\n    position: index + 1,\n    displayed_link: result.displayed_link || ''\n  }));\n\n// Extract additional metadata\nconst searchInfo = {\n  totalResults: serpApiResponse.search_information?.total_results || 0,\n  searchTime: serpApiResponse.search_information?.time_taken_displayed || 0,\n  queryPerformed: serpApiResponse.search_parameters?.q || searchParams.searchQuery\n};\n\nreturn [{\n  json: {\n    success: true,\n    data: {\n      searchQuery: searchParams.searchQuery,\n      originalQuery: searchParams.originalQuery,\n      parsedQuery: searchParams.parsedQuery,\n      results: linkedinResults,\n      totalResults: linkedinResults.length,\n      searchTime: searchInfo.searchTime,\n      totalSearchResults: searchInfo.totalResults,\n      apiUsed: \"serpapi\",\n      searchMetadata: searchInfo\n    },\n    metadata: {\n      workflow: \"search-engine\",\n      version: \"1.0.0\"\n    }\n  }\n}];"
      },
      "id": "process-serpapi-response",
      "name": "Process SerpApi Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 200]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.success }}",
              "operation": "equal",
              "value2": true
            },
            {
              "value1": "={{ $json.data.results.length }}",
              "operation": "greater",
              "value2": 0
            },
            {
              "combineOperation": "AND"
            }
          ]
        }
      },
      "id": "check-serpapi-success",
      "name": "Check SerpApi Success",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1340, 200]
    },
    {
      "parameters": {
        "url": "https://api.serpstack.com/search",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "access_key",
              "value": "={{ $credentials.serpStackApi?.accessKey || $env.SERPSTACK_ACCESS_KEY }}"
            },
            {
              "name": "query",
              "value": "={{ $json.data?.searchQuery || $json.searchQuery || $('Construct Google Search Query').first().json.searchQuery }}"
            },
            {
              "name": "engine",
              "value": "google"
            },
            {
              "name": "location",
              "value": "={{ $json.data?.parsedQuery?.location || $json.parsedQuery?.location || $('Construct Google Search Query').first().json.parsedQuery.location || 'United States' }}"
            },
            {
              "name": "google_domain",
              "value": "google.com"
            },
            {
              "name": "gl",
              "value": "us"
            },
            {
              "name": "hl",
              "value": "en"
            },
            {
              "name": "num",
              "value": "10"
            },
            {
              "name": "device",
              "value": "desktop"
            },
            {
              "name": "safe_search",
              "value": "off"
            }
          ]
        },
        "options": {}
      },
      "id": "serpstack-fallback-search",
      "name": "SerpStack Fallback Search",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1560, 100],
      "credentials": {
        "serpStackApi": {
          "id": "serpstack-credentials",
          "name": "SerpStack API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const serpStackResponse = $input.all()[0]?.json;\nconst searchParams = $(\"Construct Google Search Query\").all()[0]?.json;\n\n// DEBUG: Add comprehensive debugging to understand SerpStack response structure\nconst debugInfo = {\n  serpStackResponseKeys: Object.keys(serpStackResponse || {}),\n  serpStackResponseType: typeof serpStackResponse,\n  hasError: !!serpStackResponse.error,\n  errorMessage: serpStackResponse.error?.message || serpStackResponse.error,\n  // Check for nested response structures\n  hasResponse: !!serpStackResponse.response,\n  responseKeys: serpStackResponse.response ? Object.keys(serpStackResponse.response) : [],\n  hasOrganicResults: false,\n  organicResultsLocation: null,\n  organicResultsCount: 0\n};\n\n// FIXED: Handle different SerpStack response structures\n// SerpStack might return results in different nested structures\nlet organicResults = [];\n\n// Try different possible structures for SerpStack response\nif (serpStackResponse.organic_results) {\n  // Direct access (SerpApi-style)\n  organicResults = serpStackResponse.organic_results;\n  debugInfo.organicResultsLocation = \"serpStackResponse.organic_results\";\n  debugInfo.hasOrganicResults = true;\n} else if (serpStackResponse.response && serpStackResponse.response.organic_results) {\n  // Nested in response object\n  organicResults = serpStackResponse.response.organic_results;\n  debugInfo.organicResultsLocation = \"serpStackResponse.response.organic_results\";\n  debugInfo.hasOrganicResults = true;\n} else if (serpStackResponse.data && serpStackResponse.data.organic_results) {\n  // Nested in data object\n  organicResults = serpStackResponse.data.organic_results;\n  debugInfo.organicResultsLocation = \"serpStackResponse.data.organic_results\";\n  debugInfo.hasOrganicResults = true;\n} else if (Array.isArray(serpStackResponse.organic_results)) {\n  // Direct array\n  organicResults = serpStackResponse.organic_results;\n  debugInfo.organicResultsLocation = \"serpStackResponse.organic_results (direct array)\";\n  debugInfo.hasOrganicResults = true;\n} else if (serpStackResponse.response && Array.isArray(serpStackResponse.response.organic_results)) {\n  // Nested array\n  organicResults = serpStackResponse.response.organic_results;\n  debugInfo.organicResultsLocation = \"serpStackResponse.response.organic_results (nested array)\";\n  debugInfo.hasOrganicResults = true;\n} else {\n  // Try to find organic_results in any nested object\n  function findOrganicResults(obj, path = \"\") {\n    if (!obj || typeof obj !== \"object\") return null;\n    \n    if (Array.isArray(obj.organic_results)) {\n      return { results: obj.organic_results, path: path + \".organic_results\" };\n    }\n    \n    for (const [key, value] of Object.entries(obj)) {\n      if (typeof value === \"object\" && key !== \"organic_results\") {\n        const result = findOrganicResults(value, path + \".\" + key);\n        if (result) return result;\n      }\n    }\n    return null;\n  }\n  \n  const found = findOrganicResults(serpStackResponse, \"serpStackResponse\");\n  if (found) {\n    organicResults = found.results;\n    debugInfo.organicResultsLocation = found.path;\n    debugInfo.hasOrganicResults = true;\n  }\n}\n\ndebugInfo.organicResultsCount = Array.isArray(organicResults) ? organicResults.length : 0;\n\n// Enhanced error handling\nif (serpStackResponse.error) {\n  return [{\n    json: {\n      success: false,\n      error: \"Both primary and fallback search failed\",\n      primaryError: \"SerpApi search failed or returned no results\",\n      fallbackError: serpStackResponse.error?.message || serpStackResponse.error,\n      errorType: \"search_failed\",\n      searchParams: searchParams,\n      debugInfo: debugInfo\n    }\n  }];\n}\n\n// Check if we found organic results\nif (!organicResults || !Array.isArray(organicResults) || organicResults.length === 0) {\n  return [{\n    json: {\n      success: false,\n      error: \"Both primary and fallback search failed\",\n      primaryError: \"SerpApi search failed or returned no results\",\n      fallbackError: \"SerpStack returned no organic results\",\n      errorType: \"search_failed\",\n      searchParams: searchParams,\n      debugInfo: debugInfo\n    }\n  }];\n}\n\n// Process SerpStack results (similar to SerpApi processing)\nconst linkedinResults = organicResults\n  .filter(result => {\n    const url = result.link || result.url || '';\n    return url.includes('linkedin.com/in/') && !url.includes('/pub/');\n  })\n  .slice(0, 10)\n  .map((result, index) => ({\n    title: result.title || '',\n    url: result.link || result.url || '',\n    snippet: result.snippet || result.description || '',\n    position: index + 1,\n    displayed_link: result.displayed_link || result.domain || ''\n  }));\n\n// Extract search metadata from possible locations\nlet searchInfo = {\n  totalResults: 0,\n  searchTime: 0,\n  queryPerformed: searchParams.searchQuery\n};\n\n// Try different possible locations for search metadata\nif (serpStackResponse.search_information) {\n  searchInfo = {\n    totalResults: serpStackResponse.search_information.total_results || 0,\n    searchTime: serpStackResponse.search_information.time_taken_displayed || 0,\n    queryPerformed: serpStackResponse.search_parameters?.q || searchParams.searchQuery\n  };\n} else if (serpStackResponse.response && serpStackResponse.response.search_information) {\n  searchInfo = {\n    totalResults: serpStackResponse.response.search_information.total_results || 0,\n    searchTime: serpStackResponse.response.search_information.time_taken_displayed || 0,\n    queryPerformed: serpStackResponse.response.search_parameters?.q || searchParams.searchQuery\n  };\n}\n\nreturn [{\n  json: {\n    success: true,\n    data: {\n      searchQuery: searchParams.searchQuery,\n      originalQuery: searchParams.originalQuery,\n      parsedQuery: searchParams.parsedQuery,\n      results: linkedinResults,\n      totalResults: linkedinResults.length,\n      searchTime: searchInfo.searchTime,\n      totalSearchResults: searchInfo.totalResults,\n      apiUsed: \"serpstack\",\n      searchMetadata: searchInfo,\n      note: \"Used fallback search service - FIXED: Enhanced response structure handling\",\n      debugInfo: debugInfo\n    },\n    metadata: {\n      workflow: \"search-engine\",\n      version: \"1.0.0\"\n    }\n  }\n}];"
      },
      "id": "process-serpstack-response",
      "name": "Process SerpStack Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 100]
    },
    {
      "parameters": {
        "mode": "passthrough"
      },
      "id": "merge-search-results",
      "name": "Combine Primary and Fallback",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [1780, 300]
    },
    {
      "parameters": {
        "jsCode": "const searchResult = $input.all()[0]?.json;\n\nif (!searchResult.success) {\n  // Error already formatted, return as-is\n  return [searchResult];\n}\n\nconst { results, parsedQuery } = searchResult.data;\n\n// Score and filter results based on relevance\nconst scoredResults = results.map(result => {\n  let score = 0;\n  const title = (result.title || '').toLowerCase();\n  const snippet = (result.snippet || '').toLowerCase();\n  \n  // Job title matching (highest weight)\n  if (parsedQuery.jobTitles) {\n    parsedQuery.jobTitles.forEach(jobTitle => {\n      if (title.includes(jobTitle.toLowerCase())) {\n        score += 10;\n      }\n      if (snippet.includes(jobTitle.toLowerCase())) {\n        score += 5;\n      }\n    });\n  }\n  \n  // Skills matching\n  if (parsedQuery.skills) {\n    parsedQuery.skills.forEach(skill => {\n      if (title.includes(skill.toLowerCase())) {\n        score += 3;\n      }\n      if (snippet.includes(skill.toLowerCase())) {\n        score += 2;\n      }\n    });\n  }\n  \n  // Location matching\n  if (parsedQuery.location) {\n    if (title.includes(parsedQuery.location.toLowerCase()) || \n        snippet.includes(parsedQuery.location.toLowerCase())) {\n      score += 5;\n    }\n  }\n  \n  // Keywords matching\n  if (parsedQuery.keywords) {\n    parsedQuery.keywords.forEach(keyword => {\n      if (title.includes(keyword.toLowerCase()) || \n          snippet.includes(keyword.toLowerCase())) {\n        score += 1;\n      }\n    });\n  }\n  \n  // LinkedIn URL quality check\n  const url = result.url || '';\n  if (url.includes('/in/') && !url.match(/\\/in\\/[^\\/]+\\/$/)) {\n    score += 2; // Proper LinkedIn profile URL\n  }\n  \n  return {\n    ...result,\n    relevanceScore: score\n  };\n});\n\n// Sort by relevance score (highest first)\nscoredResults.sort((a, b) => b.relevanceScore - a.relevanceScore);\n\n// Filter out low-quality results (score < 2)\nconst filteredResults = scoredResults.filter(result => result.relevanceScore >= 2);\n\n// Return top 10 results\nconst finalResults = filteredResults.slice(0, 10);\n\n// Update search result with filtered and scored results\nsearchResult.data.results = finalResults;\nsearchResult.data.totalResults = finalResults.length;\nsearchResult.data.qualityFilter = {\n  originalCount: results.length,\n  filteredCount: finalResults.length,\n  averageScore: finalResults.length > 0 ? \n    finalResults.reduce((sum, r) => sum + r.relevanceScore, 0) / finalResults.length : 0\n};\n\nreturn [{\n  json: searchResult\n}];"
      },
      "id": "quality-filter",
      "name": "Filter and Rank Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 300]
    },
    {
      "parameters": {
        "values": {
          "json": [
            {
              "name": "success",
              "value": "={{ $json.success }}"
            },
            {
              "name": "data",
              "value": "={{ $json.data }}"
            }
          ],
          "string": [
            {
              "name": "metadata.workflow",
              "value": "search-engine"
            },
            {
              "name": "metadata.version",
              "value": "1.0.0"
            },
            {
              "name": "metadata.processingTime",
              "value": "={{ $now }}"
            },
            {
              "name": "metadata.requestId",
              "value": "={{ $runIndex }}"
            }
          ]
        },
        "options": {}
      },
      "id": "format-final-response",
      "name": "Standardize Output Format",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.2,
      "position": [2220, 300]
    }
  ],
  "connections": {
    "Search Trigger": {
      "main": [
        [
          {
            "node": "Validate Search Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Search Input": {
      "main": [
        [
          {
            "node": "Construct Google Search Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Construct Google Search Query": {
      "main": [
        [
          {
            "node": "SerpApi Google Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SerpApi Google Search": {
      "main": [
        [
          {
            "node": "Process SerpApi Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process SerpApi Results": {
      "main": [
        [
          {
            "node": "Check SerpApi Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check SerpApi Success": {
      "main": [
        [
          {
            "node": "Combine Primary and Fallback",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "SerpStack Fallback Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SerpStack Fallback Search": {
      "main": [
        [
          {
            "node": "Process SerpStack Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process SerpStack Results": {
      "main": [
        [
          {
            "node": "Combine Primary and Fallback",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Combine Primary and Fallback": {
      "main": [
        [
          {
            "node": "Filter and Rank Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter and Rank Results": {
      "main": [
        [
          {
            "node": "Standardize Output Format",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Standardize Output Format": {
      "main": []
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-12-01T18:30:00.000Z",
      "updatedAt": "2025-12-01T18:30:00.000Z",
      "id": "search-engine-tag",
      "name": "PeopleHub"
    }
  ],
  "triggerCount": 0,
  "updatedAt": "2025-12-01T18:30:00.000Z",
  "versionId": "1"
}